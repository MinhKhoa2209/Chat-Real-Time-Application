@startuml Sequence_Register_Login
title Sequence Diagram: Register / Login

actor User
participant "Frontend" as Frontend
participant "Auth API" as AuthAPI
participant "Database" as DB
participant "OAuth Provider" as OAuth

== Email/Password Login ==

User -> Frontend: Enter credentials and sign in
Frontend -> AuthAPI: POST /api/auth/signin

activate AuthAPI
AuthAPI -> DB: Query user and validate password
activate DB
DB --> AuthAPI: User data
deactivate DB

alt Valid credentials
    AuthAPI -> AuthAPI: Create JWT session
    AuthAPI --> Frontend: Return JWT token
    Frontend -> User: Redirect to home
else Invalid credentials
    AuthAPI --> Frontend: Error
    Frontend -> User: Display error
end
deactivate AuthAPI

== OAuth Login ==

User -> Frontend: Click OAuth provider
Frontend -> OAuth: Redirect for authorization

activate OAuth
OAuth -> User: Authorization page
User -> OAuth: Authorize
OAuth --> Frontend: Return access token
deactivate OAuth

Frontend -> AuthAPI: POST /api/auth/callback

activate AuthAPI
AuthAPI -> OAuth: Validate token
OAuth --> AuthAPI: Token valid
AuthAPI -> DB: Find or create user
DB --> AuthAPI: User data
AuthAPI -> AuthAPI: Create JWT session
AuthAPI --> Frontend: Return JWT token
deactivate AuthAPI

Frontend -> User: Redirect to home

@enduml

@startuml Sequence_Create_Conversation
title Sequence Diagram: Create Conversation (1-1 or Group)

actor User
participant "Frontend" as Frontend
participant "Conversation API" as ConvAPI
participant "Database" as DB
participant "Pusher Server" as Pusher

== Create 1-1 Conversation ==

User -> Frontend: Select user and start chat
Frontend -> ConvAPI: POST /api/conversations

activate ConvAPI
ConvAPI -> DB: Check if conversation exists

alt Conversation exists
    DB --> ConvAPI: Existing conversation
    ConvAPI --> Frontend: Return conversation
else Create new
    ConvAPI -> DB: Create conversation and connect users
    DB --> ConvAPI: New conversation
    ConvAPI -> Pusher: Trigger "conversation:new"
    Pusher -> Pusher: Broadcast to participants
    ConvAPI --> Frontend: Return new conversation
end
deactivate ConvAPI

Frontend -> User: Navigate to conversation

== Create Group Chat ==

User -> Frontend: Enter name, select members, create
Frontend -> ConvAPI: POST /api/conversations (isGroup: true)

activate ConvAPI
ConvAPI -> ConvAPI: Validate input

alt Validation fails
    ConvAPI --> Frontend: Error
    Frontend -> User: Display error
else Validation succeeds
    ConvAPI -> DB: Create group conversation
    DB --> ConvAPI: New group
    ConvAPI -> Pusher: Trigger "conversation:new" to all members
    Pusher -> Pusher: Broadcast to all members
    ConvAPI --> Frontend: Return group conversation
    Frontend -> User: Navigate to group chat
end
deactivate ConvAPI

@enduml

@startuml Sequence_Send_Message
title Sequence Diagram: Send Message (Text/Image/File)

actor User
participant "Frontend" as Frontend
participant "Message API" as MsgAPI
participant "Database" as DB
participant "Cloudinary" as Cloudinary
participant "Pusher Server" as Pusher

== Send Text Message ==

User -> Frontend: Type and send message
Frontend -> MsgAPI: POST /api/messages

activate MsgAPI
MsgAPI -> DB: Save message and update conversation
activate DB
DB --> MsgAPI: Message saved
deactivate DB

MsgAPI -> Pusher: Trigger "messages:new"
Pusher --> Frontend: Real-time event
MsgAPI --> Frontend: Return message
deactivate MsgAPI

Frontend -> User: Display message

== Send Image/File Message ==

User -> Frontend: Select and upload file
Frontend -> Cloudinary: Upload file
Cloudinary --> Frontend: Return URL

Frontend -> MsgAPI: POST /api/messages (with file URL)

activate MsgAPI
MsgAPI -> DB: Save message with file URL
activate DB
DB --> MsgAPI: Message saved
deactivate DB

MsgAPI -> Pusher: Trigger "messages:new"
Pusher --> Frontend: Real-time event
MsgAPI --> Frontend: Return message
deactivate MsgAPI

Frontend -> User: Display file message

@enduml

@startuml Sequence_Chat_AI
title Sequence Diagram: Chat with AI Assistant (Gemini)

actor User
participant "Frontend" as Frontend
participant "Message API" as MsgAPI
participant "Gemini API" as GeminiAPI
participant "Database" as DB
participant "Pusher Server" as Pusher

User -> Frontend: Type message in AI chat
Frontend -> MsgAPI: POST /api/messages

activate MsgAPI
MsgAPI -> DB: Save user message
DB --> MsgAPI: Message saved

MsgAPI -> DB: Load memory and knowledge base
DB --> MsgAPI: Context data

MsgAPI -> MsgAPI: Build system prompt
MsgAPI -> GeminiAPI: POST /v1/chat

activate GeminiAPI

alt API call successful
    GeminiAPI -> GeminiAPI: Generate response
    GeminiAPI --> MsgAPI: AI response text
    deactivate GeminiAPI
    
    MsgAPI -> DB: Save AI message
    DB --> MsgAPI: AI message saved
    MsgAPI -> Pusher: Trigger "messages:new"
    Pusher --> Frontend: Real-time AI response
    MsgAPI --> Frontend: Return AI message
    Frontend -> User: Display AI response
else API error
    GeminiAPI --> MsgAPI: Error
    deactivate GeminiAPI
    
    MsgAPI -> DB: Save error message
    MsgAPI -> Pusher: Trigger "messages:new"
    Pusher --> Frontend: Real-time error
    MsgAPI --> Frontend: Return error
    Frontend -> User: Display error message
end
deactivate MsgAPI

@enduml
